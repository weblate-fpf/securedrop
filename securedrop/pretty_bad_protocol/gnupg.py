#
# This file is part of python-gnupg, a Python interface to GnuPG.
# Copyright © 2013 Isis Lovecruft, <isis@leap.se> 0xA3ADB67A2CDB8B35
#           © 2013 Andrej B.
#           © 2013 LEAP Encryption Access Project
#           © 2008-2012 Vinay Sajip
#           © 2005 Steve Traugott
#           © 2004 A.M. Kuchling
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the included LICENSE file for details.

"""gnupg.py
===========
A Python interface to GnuPG.

.. moduleauthor:: Isis Lovecruft <isis@patternsinthevoid.net>
                  see also :attr:`gnupg.__authors__`
.. license:: see :attr:`gnupg.__license__`
.. info:: https://github.com/isislovecruft/python-gnupg
"""

import encodings
import functools
import os
import tempfile
import textwrap
import time
from codecs import open

#: see :pep:`328` http://docs.python.org/2.5/whatsnew/pep-328.html
from . import _trust, _util
from ._meta import GPGBase
from ._parsers import _fix_unsafe
from ._util import _is_list_or_tuple, _make_binary_stream, log


class GPG(GPGBase):
    """Python interface for handling interactions with GnuPG, including keyfile
    generation, keyring maintainance, import and export, encryption and
    decryption, sending to and recieving from keyservers, and signing and
    verification.
    """

    #: The number of simultaneous keyids we should list operations like
    #: '--list-sigs' to:
    _batch_limit = 25

    def __init__(  # type: ignore[no-untyped-def]
        self,
        binary=None,
        homedir=None,
        verbose=False,
        use_agent=False,
        keyring=None,
        secring=None,
        ignore_homedir_permissions=False,
        options=None,
    ):
        """Initialize a GnuPG process wrapper.

        :param str binary: Name for GnuPG binary executable. If the absolute
                           path is not given, the environment variable
                           ``$PATH`` is searched for the executable and
                           checked that the real uid/gid of the user has
                           sufficient permissions.

        :param str homedir: Full pathname to directory containing the public
                            and private keyrings. Default is
                            `~/.config/python-gnupg`.

        :type ignore_homedir_permissions: :obj:`bool`
        :param ignore_homedir_permissions: If true, bypass check that homedir
                                           be writable.

        :type verbose: :obj:`str` or :obj:`int` or :obj:`bool`
        :param verbose: String or numeric value to pass to GnuPG's
                        ``--debug-level`` option. See the GnuPG man page for
                        the list of valid options. If False, debug output is
                        not generated by the GnuPG binary. If True, defaults
                        to ``--debug-level basic.``

        :param str keyring: Name of keyring file containing public key data.
                            If unspecified, defaults to :file:`pubring.gpg` in
                            the **homedir** directory.

        :param str secring: Name of alternative secret keyring file to use. If
                            left unspecified, this will default to using
                            :file:`secring.gpg` in the **homedir** directory,
                            and create that file if it does not exist.

        :param list options: A list of additional options to pass to the GnuPG
                             binary.

        :raises: A :exc:`~exceptions.RuntimeError` with explanation message
                 if there is a problem invoking GnuPG.

        Example:

        >>> import gnupg
        GnuPG logging disabled...
        >>> gpg = gnupg.GPG(homedir='doctests')
        >>> gpg.keyring
        './doctests/pubring.gpg'
        >>> gpg.secring
        './doctests/secring.gpg'
        >>> gpg.use_agent
        False
        >>> gpg.binary
        '/usr/bin/gpg'
        """

        super().__init__(
            binary=binary,
            home=homedir,
            keyring=keyring,
            secring=secring,
            options=options,
            verbose=verbose,
            use_agent=use_agent,
            ignore_homedir_permissions=ignore_homedir_permissions,
        )

        log.info(
            textwrap.dedent(
                """
        Initialised settings:
        binary: {}
        binary version: {}
        homedir: {}
        ignore_homedir_permissions: {}
        keyring: {}
        secring: {}
        default_preference_list: {}
        keyserver: {}
        options: {}
        verbose: {}
        use_agent: {}
        """.format(
                    self.binary,
                    self.binary_version,
                    self.homedir,
                    self.ignore_homedir_permissions,
                    self.keyring,
                    self.secring,
                    self.default_preference_list,
                    self.keyserver,
                    self.options,
                    str(self.verbose),
                    str(self.use_agent),
                )
            )
        )

        self._batch_dir = os.path.join(self.homedir, "batch-files")
        self._key_dir = os.path.join(self.homedir, "generated-keys")

        #: The keyring used in the most recently created batch file
        self.temp_keyring = None
        #: The secring used in the most recently created batch file
        self.temp_secring = None

        # Make sure that the trustdb exists, or else GnuPG will exit with a
        # fatal error (at least it does with GnuPG>=2.0.0):
        self.create_trustdb()

        # The --no-use-agent and --use-agent options were deprecated in GnuPG
        # 2.x, so we should set use_agent to None here to avoid having
        # GPGBase._make_args() add either one.
        self.use_agent = None

    @functools.wraps(_trust._create_trustdb)
    def create_trustdb(self):  # type: ignore[no-untyped-def]
        _trust._create_trustdb(self)

    # For backward compatibility with python-gnupg<=1.3.1:
    _create_trustdb = create_trustdb

    @functools.wraps(_trust.fix_trustdb)
    def fix_trustdb(self, trustdb=None):  # type: ignore[no-untyped-def]
        _trust.fix_trustdb(self)

    # For backward compatibility with python-gnupg<=1.3.1:
    _fix_trustdb = fix_trustdb

    # TODO: this is only used by tests
    def import_keys(self, key_data):  # type: ignore[no-untyped-def]
        """
        Import the key_data into our keyring.

        >>> import shutil
        >>> shutil.rmtree("doctests")
        >>> gpg = gnupg.GPG(homedir="doctests")
        >>> inpt = gpg.gen_key_input()
        >>> key1 = gpg.gen_key(inpt)
        >>> print1 = str(key1.fingerprint)
        >>> pubkey1 = gpg.export_keys(print1)
        >>> seckey1 = gpg.export_keys(print1,secret=True)
        >>> key2 = gpg.gen_key(inpt)
        >>> print2 = key2.fingerprint
        >>> seckeys = gpg.list_keys(secret=True)
        >>> pubkeys = gpg.list_keys()
        >>> assert print1 in seckeys.fingerprints
        >>> assert print1 in pubkeys.fingerprints
        >>> str(gpg.delete_keys(print1))
        'Must delete secret key first'
        >>> str(gpg.delete_keys(print1,secret=True))
        'ok'
        >>> str(gpg.delete_keys(print1))
        'ok'
        >>> pubkeys = gpg.list_keys()
        >>> assert not print1 in pubkeys.fingerprints
        >>> result = gpg.import_keys(pubkey1)
        >>> pubkeys = gpg.list_keys()
        >>> seckeys = gpg.list_keys(secret=True)
        >>> assert not print1 in seckeys.fingerprints
        >>> assert print1 in pubkeys.fingerprints
        >>> result = gpg.import_keys(seckey1)
        >>> assert result
        >>> seckeys = gpg.list_keys(secret=True)
        >>> assert print1 in seckeys.fingerprints
        """
        # xxx need way to validate that key_data is actually a valid GPG key
        #     it might be possible to use --list-packets and parse the output

        result = self._result_map["import"](self)
        log.info("Importing: %r", key_data[:256])
        data = _make_binary_stream(key_data, self._encoding)
        self._handle_io(["--import"], data, result, binary=True)
        data.close()
        return result

    def delete_keys(self, fingerprints, secret=False, subkeys=False):  # type: ignore[no-untyped-def] # noqa
        """Delete a key, or list of keys, from the current keyring.

        The keys must be referred to by their full fingerprints for GnuPG to
        delete them. If ``secret=True``, the corresponding secret keyring will
        be deleted from :obj:`.secring`.

        :type fingerprints: :obj:`str` or :obj:`list` or :obj:`tuple`
        :param fingerprints: A string, or a list/tuple of strings,
                             representing the fingerprint(s) for the key(s)
                             to delete.

        :param bool secret: If True, delete the corresponding secret key(s)
                            also. (default: False)

        :param bool subkeys: If True, delete the secret subkey first, then the
                             public key. (default: False) Same as:
                             :command:`$gpg --delete-secret-and-public-key 0x12345678`.
        """
        which = "keys"
        if secret:
            which = "secret-keys"
        if subkeys:
            which = "secret-and-public-keys"

        if _is_list_or_tuple(fingerprints):
            fingerprints = " ".join(fingerprints)

        args = ["--batch"]
        args.append(f"--delete-{which} {fingerprints}")

        result = self._result_map["delete"](self)
        p = self._open_subprocess(args)
        self._collect_output(p, result, stdin=p.stdin)
        return result

    def export_keys(self, keyids, secret=False, subkeys=False, passphrase=None):  # type: ignore[no-untyped-def] # noqa
        """Export the indicated ``keyids``.

        :param str keyids: A keyid or fingerprint in any format that GnuPG will
            accept.
        :param bool secret: If True, export only the secret key.
        :param bool subkeys: If True, export the secret subkeys.
        :param Optional[str] passphrase: if exporting secret keys, use this
            passphrase to authenticate
        """
        which = ""
        if subkeys:
            which = "-secret-subkeys"
        elif secret:
            which = "-secret-keys"
        else:
            # No secret key material, ignore passphrase arg
            passphrase = None

        if _is_list_or_tuple(keyids):
            keyids = " ".join(["%s" % k for k in keyids])

        args = ["--armor", f"--export{which} {keyids}"]
        result = self._result_map["export"](self)

        # Yes we need to pass in an empty temporary file here,
        # please don't ask me why. I can't get it to work otherwise.
        with tempfile.NamedTemporaryFile() as tmp:
            self._handle_io(args, tmp.name, result, passphrase, binary=True)

        log.debug(f"Exported:{os.linesep}{result.fingerprints!r}")
        return result.data.decode(self._encoding, self._decode_errors)

    def list_keys(self, secret=False):  # type: ignore[no-untyped-def]
        """List the keys currently in the keyring.

        The GnuPG option '--show-photos', according to the GnuPG manual, "does
        not work with --with-colons", but since we can't rely on all versions
        of GnuPG to explicitly handle this correctly, we should probably
        include it in the args.

        >>> import shutil
        >>> shutil.rmtree("doctests")
        >>> gpg = GPG(homedir="doctests")
        >>> input = gpg.gen_key_input()
        >>> result = gpg.gen_key(input)
        >>> print1 = result.fingerprint
        >>> result = gpg.gen_key(input)
        >>> print2 = result.fingerprint
        >>> pubkeys = gpg.list_keys()
        >>> assert print1 in pubkeys.fingerprints
        >>> assert print2 in pubkeys.fingerprints
        """
        which = "public-keys"
        if secret:
            which = "secret-keys"

        args = []
        args.append("--fixed-list-mode")
        args.append("--fingerprint")
        args.append("--with-colons")
        args.append("--list-options no-show-photos")
        args.append("--list-%s" % (which))

        p = self._open_subprocess(args)

        # there might be some status thingumy here I should handle... (amk)
        # ...nope, unless you care about expired sigs or keys (stevegt)

        # Get the response information
        result = self._result_map["list"](self)
        self._collect_output(p, result, stdin=p.stdin)
        self._parse_keys(result)
        return result

    def list_packets(self, raw_data):  # type: ignore[no-untyped-def]
        """List the packet contents of a file."""
        args = ["--list-packets"]
        result = self._result_map["packets"](self)
        self._handle_io(args, _make_binary_stream(raw_data, self._encoding), result)
        return result

    def _parse_keys(self, result):  # type: ignore[no-untyped-def]
        lines = result.data.decode(self._encoding, self._decode_errors).splitlines()
        valid_keywords = "pub uid sec fpr sub sig rev".split()
        for line in lines:
            if self.verbose:
                print(line)
            log.debug("%r", line.rstrip())
            if not line:
                break
            L = line.strip().split(":")
            if not L:
                continue
            keyword = L[0]
            if keyword in valid_keywords:
                getattr(result, keyword)(L)

    def gen_key(self, input):  # type: ignore[no-untyped-def]
        """Generate a GnuPG key through batch file key generation. See
        :meth:`GPG.gen_key_input()` for creating the control input.

        >>> import gnupg
        >>> gpg = gnupg.GPG(homedir="doctests")
        >>> key_input = gpg.gen_key_input()
        >>> key = gpg.gen_key(key_input)
        >>> assert key.fingerprint

        :param dict input: A dictionary of parameters and values for the new
                           key.
        :returns: The result mapping with details of the new key, which is a
                  :class:`GenKey <gnupg._parsers.GenKey>` object.
        """
        args = ["--gen-key --cert-digest-algo SHA512 --batch"]
        key = self._result_map["generate"](self)
        f = _make_binary_stream(input, self._encoding)
        self._handle_io(args, f, key, binary=True)
        f.close()

        fpr = str(key.fingerprint)
        if len(fpr) == 20:
            for d in map(lambda x: os.path.dirname(x), [self.temp_keyring, self.temp_secring]):
                if not os.path.exists(d):
                    os.makedirs(d)

            if self.temp_keyring and os.path.isfile(self.temp_keyring):
                prefix = os.path.join(self.temp_keyring, fpr)
                try:
                    os.rename(self.temp_keyring, prefix + ".pubring")
                except OSError as ose:
                    log.error(str(ose))

            if self.temp_secring and os.path.isfile(self.temp_secring):
                prefix = os.path.join(self.temp_secring, fpr)
                try:
                    os.rename(self.temp_secring, prefix + ".secring")
                except OSError as ose:
                    log.error(str(ose))

        log.info("Key created. Fingerprint: %s" % fpr)
        key.keyring = self.temp_keyring
        key.secring = self.temp_secring
        self.temp_keyring = None
        self.temp_secring = None

        return key

    def gen_key_input(self, separate_keyring=False, save_batchfile=False, testing=False, **kwargs):  # type: ignore[no-untyped-def] # noqa
        """Generate a batch file for input to :meth:`~gnupg.GPG.gen_key`.

        The GnuPG batch file key generation feature allows unattended key
        generation by creating a file with special syntax and then providing it
        to: :command:`gpg --gen-key --batch`. Batch files look like this:

        |  Name-Real: Alice
        |  Name-Email: alice@inter.net
        |  Expire-Date: 2014-04-01
        |  Key-Type: RSA
        |  Key-Length: 4096
        |  Key-Usage: cert
        |  Subkey-Type: RSA
        |  Subkey-Length: 4096
        |  Subkey-Usage: encrypt,sign,auth
        |  Passphrase: sekrit
        |  %pubring foo.gpg
        |  %secring sec.gpg
        |  %commit

        which is what this function creates for you. All of the available,
        non-control parameters are detailed below (control parameters are the
        ones which begin with a '%'). For example, to generate the batch file
        example above, use like this:

        >>> import gnupg
        GnuPG logging disabled...
        >>> from __future__ import print_function
        >>> gpg = gnupg.GPG(homedir='doctests')
        >>> alice = { 'name_real': 'Alice',
        ...     'name_email': 'alice@inter.net',
        ...     'expire_date': '2014-04-01',
        ...     'key_type': 'RSA',
        ...     'key_length': 4096,
        ...     'key_usage': '',
        ...     'subkey_type': 'RSA',
        ...     'subkey_length': 4096,
        ...     'subkey_usage': 'encrypt,sign,auth',
        ...     'passphrase': 'sekrit'}
        >>> alice_input = gpg.gen_key_input(**alice)
        >>> print(alice_input)
        Key-Type: RSA
        Subkey-Type: RSA
        Subkey-Usage: encrypt,sign,auth
        Expire-Date: 2014-04-01
        Passphrase: sekrit
        Name-Real: Alice
        Name-Email: alice@inter.net
        Key-Length: 4096
        Subkey-Length: 4096
        %pubring ./doctests/alice.pubring.gpg
        %secring ./doctests/alice.secring.gpg
        %commit
        <BLANKLINE>
        >>> alice_key = gpg.gen_key(alice_input)
        >>> assert alice_key is not None
        >>> assert alice_key.fingerprint is not None
        >>> message = "no one else can read my sekrit message"
        >>> encrypted = gpg.encrypt(message, alice_key.fingerprint)
        >>> assert isinstance(encrypted.data, str)

        :param bool separate_keyring: Specify for the new key to be written to
            a separate pubring.gpg and secring.gpg. If True,
            :meth:`~gnupg.GPG.gen_key` will automatically rename the separate
            keyring and secring to whatever the fingerprint of the generated
            key ends up being, suffixed with '.pubring' and '.secring'
            respectively.

        :param bool save_batchfile: Save a copy of the generated batch file to
            disk in a file named <name_real>.batch, where <name_real> is the
            ``name_real`` parameter stripped of punctuation, spaces, and
            non-ascii characters.

        :param bool testing: Uses a faster, albeit insecure random number
            generator to create keys. This should only be used for testing
            purposes, for keys which are going to be created and then soon
            after destroyed, and never for the generation of actual use keys.

        :param str name_real: The name field of the UID in the generated key.
        :param str name_comment: The comment in the UID of the generated key.

        :param str name_email: The email in the UID of the generated key.
            (default: ``$USER`` @ :command:`hostname` ) Remember to use UTF-8
            encoding for the entirety of the UID. At least one of
            ``name_real``, ``name_comment``, or ``name_email`` must be
            provided, or else no user ID is created.

        :param str key_type: One of 'RSA', 'DSA', 'ELG-E', or 'default'.
            (default: 'RSA', if using GnuPG v1.x, otherwise 'default') Starts
            a new parameter block by giving the type of the primary key. The
            algorithm must be capable of signing. This is a required
            parameter. The algorithm may either be an OpenPGP algorithm number
            or a string with the algorithm name. The special value ‘default’
            may be used for algo to create the default key type; in this case
            a ``key_usage`` should not be given and 'default' must also be
            used for ``subkey_type``.

        :param int key_length: The requested length of the generated key in
            bits. (Default: 4096)

        :param str key_grip: hexstring This is an optional hexidecimal string
            which is used to generate a CSR or certificate for an already
            existing key. ``key_length`` will be ignored if this parameter
            is given.

        :param str key_usage: Space or comma delimited string of key
            usages. Allowed values are ‘encrypt’, ‘sign’, and ‘auth’. This is
            used to generate the key flags. Please make sure that the
            algorithm is capable of this usage. Note that OpenPGP requires
            that all primary keys are capable of certification, so no matter
            what usage is given here, the ‘cert’ flag will be on. If no
            ‘Key-Usage’ is specified and the ‘Key-Type’ is not ‘default’, all
            allowed usages for that particular algorithm are used; if it is
            not given but ‘default’ is used the usage will be ‘sign’.

        :param str subkey_type: This generates a secondary key
            (subkey). Currently only one subkey can be handled. See also
            ``key_type`` above.

        :param int subkey_length: The length of the secondary subkey in bits.

        :param str subkey_usage: Key usage for a subkey; similar to
            ``key_usage``.

        :type expire_date: :obj:`int` or :obj:`str`
        :param expire_date: Can be specified as an iso-date or as
            <int>[d|w|m|y] Set the expiration date for the key (and the
            subkey). It may either be entered in ISO date format (2000-08-15)
            or as number of days, weeks, month or years. The special notation
            "seconds=N" is also allowed to directly give an Epoch
            value. Without a letter days are assumed. Note that there is no
            check done on the overflow of the type used by OpenPGP for
            timestamps. Thus you better make sure that the given value make
            sense. Although OpenPGP works with time intervals, GnuPG uses an
            absolute value internally and thus the last year we can represent
            is 2105.

        :param str creation_date: Set the creation date of the key as stored
            in the key information and which is also part of the fingerprint
            calculation. Either a date like "1986-04-26" or a full timestamp
            like "19860426T042640" may be used. The time is considered to be
            UTC. If it is not given the current time is used.

        :param str passphrase: The passphrase for the new key. The default is
            to not use any passphrase. Note that GnuPG>=2.1.x will not allow
            you to specify a passphrase for batch key generation -- GnuPG will
            ignore the **passphrase** parameter, stop, and ask the user for
            the new passphrase.  However, we can put the command
            ``%no-protection`` into the batch key generation file to allow a
            passwordless key to be created, which can then have its passphrase
            set later with ``--edit-key``.

        :param str preferences: Set the cipher, hash, and compression
            preference values for this key. This expects the same type of
            string as the sub-command ‘setpref’ in the --edit-key menu.

        :param str revoker: Should be given as 'algo:fpr' (case sensitive).
            Add a designated revoker to the generated key. Algo is the public
            key algorithm of the designated revoker (i.e. RSA=1, DSA=17, etc.)
            fpr is the fingerprint of the designated revoker. The optional
            ‘sensitive’ flag marks the designated revoker as sensitive
            information. Only v4 keys may be designated revokers.

        :param str keyserver: This is an optional parameter that specifies the
            preferred keyserver URL for the key.

        :param str handle: This is an optional parameter only used with the
            status lines ``KEY_CREATED`` and ``KEY_NOT_CREATED``. string may
            be up to 100 characters and should not contain spaces. It is
            useful for batch key generation to associate a key parameter block
            with a status line.

        :rtype: str
        :returns: A suitable input string for the :meth:`GPG.gen_key` method,
            the latter of which will create the new keypair.

        See `this GnuPG Manual section`__ for more details.

        __ http://www.gnupg.org/documentation/manuals/gnupg-devel/Unattended-GPG-key-generation.html
        """
        #: A boolean for determining whether to set subkey_type to 'default'
        default_type = False

        parms = {}

        parms.setdefault("Key-Type", "default")
        log.debug(
            "GnuPG v{} detected: setting default key type to {}.".format(
                self.binary_version, parms["Key-Type"]
            )
        )
        parms.setdefault("Key-Length", 4096)
        parms.setdefault("Name-Real", "Autogenerated Key")
        parms.setdefault("Expire-Date", _util._next_year())

        name_email = kwargs.get("name_email")
        uidemail = _util.create_uid_email(name_email)
        parms.setdefault("Name-Email", uidemail)

        if testing:
            # This specific comment string is required by (some? all?)
            # versions of GnuPG to use the insecure PRNG:
            parms.setdefault("Name-Comment", "insecure!")

        for key, val in list(kwargs.items()):
            key = key.replace("_", "-").title()
            # to set 'cert', 'Key-Usage' must be blank string
            if key not in ("Key-Usage", "Subkey-Usage") and str(val).strip():
                parms[key] = val

        # if Key-Type is 'default', make Subkey-Type also be 'default'
        if parms["Key-Type"] == "default":
            default_type = True
            for field in (
                "Key-Usage",
                "Subkey-Usage",
            ):
                try:
                    parms.pop(field)  # toss these out, handle manually
                except KeyError:
                    pass

        # Key-Type must come first, followed by length
        out = "Key-Type: %s\n" % parms.pop("Key-Type")
        out += "Key-Length: %d\n" % parms.pop("Key-Length")
        if "Subkey-Type" in parms:
            out += "Subkey-Type: %s\n" % parms.pop("Subkey-Type")
        elif default_type:
            out += "Subkey-Type: default\n"
        if "Subkey-Length" in parms:
            out += "Subkey-Length: %s\n" % parms.pop("Subkey-Length")

        for key, val in list(parms.items()):
            out += f"{key}: {val}\n"

        # There is a problem where, in the batch files, if the '%%pubring'
        # and '%%secring' are given as any static string, i.e. 'pubring.gpg',
        # that file will always get rewritten without confirmation, killing
        # off any keys we had before. So in the case where we wish to
        # generate a bunch of keys and then do stuff with them, we should not
        # give 'pubring.gpg' as our keyring file, otherwise we will lose any
        # keys we had previously.

        if separate_keyring:
            ring = str(uidemail + "_" + str(int(time.time())))
            self.temp_keyring = os.path.join(self.homedir, ring + ".pubring")
            self.temp_secring = os.path.join(self.homedir, ring + ".secring")
            out += "%%pubring %s\n" % self.temp_keyring
            out += "%%secring %s\n" % self.temp_secring

        if testing:
            # see TODO file, tag :compatibility:gen_key_input:
            #
            # Add version detection before the '%no-protection' flag.
            out += "%no-protection\n"
            out += "%transient-key\n"

        out += "%commit\n"

        # if we've been asked to save a copy of the batch file:
        if save_batchfile and parms["Name-Email"] != uidemail:
            asc_uid = encodings.normalize_encoding(parms["Name-Email"])
            filename = _fix_unsafe(asc_uid) + _util._now() + ".batch"
            save_as = os.path.join(self._batch_dir, filename)
            readme = os.path.join(self._batch_dir, "README")

            if not os.path.exists(self._batch_dir):
                os.makedirs(self._batch_dir)

                # the following pulls the link to GnuPG's online batchfile
                # documentation from this function's docstring and sticks it
                # in a README file in the batch directory:

                if getattr(self.gen_key_input, "__doc__", None) is not None:
                    docs = self.gen_key_input.__doc__
                else:
                    docs = ""  # docstring=None if run with "python -OO"
                links = "\n".join(x.strip() for x in docs.splitlines()[-2:])
                explain = """
This directory was created by python-gnupg, on {}, and
it contains saved batch files, which can be given to GnuPG to automatically
generate keys. Please see
{}""".format(
                    _util.now(), links
                )  # sometimes python is awesome.

                with open(readme, "a+") as fh:
                    [fh.write(line) for line in explain]

            with open(save_as, "a+") as batch_file:
                [batch_file.write(line) for line in out]

        return out

    def decrypt_file(self, filename, always_trust=False, passphrase=None, output=None):  # type: ignore[no-untyped-def] # noqa
        """Decrypt the contents of a file-like object ``filename`` .

        :param str filename: A file-like object to decrypt.
        :param bool always_trust: Instruct GnuPG to ignore trust checks.
        :param str passphrase: The passphrase for the secret key used for decryption.
        :param str output: A filename to write the decrypted output to.
        """
        args = ["--decrypt"]
        if output:  # write the output to a file with the specified name
            if os.path.exists(output):
                os.remove(output)  # to avoid overwrite confirmation message
            args.append("--output %s" % output)
        if always_trust:
            args.append("--always-trust")
        result = self._result_map["crypt"](self)
        self._handle_io(args, filename, result, passphrase, binary=True)
        log.debug("decrypt result: %r", result.data)
        return result
